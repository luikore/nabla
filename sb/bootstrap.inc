// GENERATED BY mini-sb.rb WITH sb.sb

return NODE(Main, 1, LIST(NODE(Lex, 2, TOKEN("kw.lex", "Main"), LIST(NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(PredefAnchor, 1, TOKEN("anchor", "\\z")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":parse"), LIST()))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(112),
VAL_FROM_INT(97),
VAL_FROM_INT(116),
VAL_FROM_INT(116),
VAL_FROM_INT(101),
VAL_FROM_INT(114),
VAL_FROM_INT(110),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.pattern"))))))),
NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(64),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.pattern"),
VAL_FROM_INT(1))))))),
NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "*")),
VAL_FROM_INT(61),
VAL_FROM_INT(32))))), LIST()))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(118),
VAL_FROM_INT(97),
VAL_FROM_INT(114),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.var"))))))),
NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(122)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.var"),
VAL_FROM_INT(1))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(108),
VAL_FROM_INT(101),
VAL_FROM_INT(120),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.lex"))))))),
NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(42), TOKEN("quantifier", "?")),
NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(90)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.context"),
VAL_FROM_INT(1))))))),
NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "*")),
VAL_FROM_INT(61),
VAL_FROM_INT(32))))), LIST()),
NODE(RefContext, 1, TOKEN("name.context", "Lex")))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(112),
VAL_FROM_INT(101),
VAL_FROM_INT(103),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.peg"))))))),
NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(90)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.context"),
VAL_FROM_INT(1))))))),
NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "*")),
VAL_FROM_INT(61),
VAL_FROM_INT(32))))), LIST()),
NODE(RefContext, 1, TOKEN("name.context", "Peg")))),
NODE(SeqLexRules, 1, LIST(NODE(RefContext, 1, TOKEN("name.context", "String")))),
NODE(SeqLexRules, 1, LIST(NODE(RefContext, 1, TOKEN("name.context", "Regexp")))),
NODE(RefPartialContext, 1, TOKEN("name.context.partial", "*Spaces")))),
NODE(Lex, 2, TOKEN("kw.lex", "Lex"), LIST(NODE(BeginCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("[")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.lex"))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("]")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.lex"))),
NODE(Call, 2, TOKEN("name.func", ":parse"), LIST()))))))),
NODE(SeqLexRules, 1, LIST(NODE(RefContext, 1, TOKEN("name.context", "Regexp")))),
NODE(SeqLexRules, 1, LIST(NODE(RefContext, 1, TOKEN("name.context", "String")))),
NODE(SeqLexRules, 1, LIST(NODE(RefContext, 1, TOKEN("name.context", "Callback")))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(98),
VAL_FROM_INT(101),
VAL_FROM_INT(103),
VAL_FROM_INT(105),
VAL_FROM_INT(110),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.begin"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(101),
VAL_FROM_INT(110),
VAL_FROM_INT(100),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.end"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(42),
NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(90)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.context.partial"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(90)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.context"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(122)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.var"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(PredefAnchor, 1, TOKEN("anchor", "$")),
NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(122)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.var.global"))))))))),
NODE(RefPartialContext, 1, TOKEN("name.context.partial", "*Spaces")))),
NODE(Lex, 2, TOKEN("kw.lex", "Peg"), LIST(NODE(BeginCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("[")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.peg"))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("]")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.peg"))),
NODE(Call, 2, TOKEN("name.func", ":parse"), LIST()))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(90)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")),
NODE(Quantified, 2, NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(46),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")))))), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.rule"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(122)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")),
NODE(Quantified, 2, NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(45),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")))))), TOKEN("quantifier", "*")),
NODE(Quantified, 2, NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(46),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")),
NODE(Quantified, 2, NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(45),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")))))), TOKEN("quantifier", "*")))))), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.token"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c(":")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.def"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(42), VAL_FROM_INT(42)),
NODE(CharRange, 2, VAL_FROM_INT(63), VAL_FROM_INT(63)),
NODE(CharRange, 2, VAL_FROM_INT(43), VAL_FROM_INT(43)))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.quantifier"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("!")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.extract"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("?!")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.extract.maybe"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(62), VAL_FROM_INT(62)),
NODE(CharRange, 2, VAL_FROM_INT(60), VAL_FROM_INT(60)))),
NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(42), VAL_FROM_INT(42)),
NODE(CharRange, 2, VAL_FROM_INT(63), VAL_FROM_INT(63)),
NODE(CharRange, 2, VAL_FROM_INT(43), VAL_FROM_INT(43)))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.branch.quantified"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(47),
NODE(PredefAnchor, 1, TOKEN("anchor", "$")),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.branch.op-table"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("/")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.branch"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(RefContext, 1, TOKEN("name.context", "Callback")))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(38), VAL_FROM_INT(38)),
NODE(CharRange, 2, VAL_FROM_INT(94), VAL_FROM_INT(94)))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.lookahead"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(64),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.pattern"))))))))),
NODE(RefPartialContext, 1, TOKEN("name.context.partial", "*Spaces")))),
NODE(Lex, 2, TOKEN("kw.lex", "Callback"), LIST(NODE(BeginCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("{")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.code"))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("}")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.code"))),
NODE(Call, 2, TOKEN("name.func", ":parse"), LIST()))))))),
NODE(SeqLexRules, 1, LIST(NODE(RefContext, 1, TOKEN("name.context", "String")))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(36),
NODE(Quantified, 2, VAL_FROM_INT(45), TOKEN("quantifier", "?")),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\d")), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.var.capture"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(58),
NODE(Quantified, 2, NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")),
NODE(CharRange, 2, VAL_FROM_INT(43), VAL_FROM_INT(43)),
NODE(CharRange, 2, VAL_FROM_INT(45), VAL_FROM_INT(45)),
NODE(CharRange, 2, VAL_FROM_INT(42), VAL_FROM_INT(42)),
NODE(CharRange, 2, VAL_FROM_INT(47), VAL_FROM_INT(47)),
NODE(CharRange, 2, VAL_FROM_INT(94), VAL_FROM_INT(94)),
NODE(CharRange, 2, VAL_FROM_INT(38), VAL_FROM_INT(38)),
NODE(CharRange, 2, VAL_FROM_INT(124), VAL_FROM_INT(124)),
NODE(CharRange, 2, VAL_FROM_INT(60), VAL_FROM_INT(60)),
NODE(CharRange, 2, VAL_FROM_INT(62), VAL_FROM_INT(62)),
NODE(CharRange, 2, VAL_FROM_INT(61), VAL_FROM_INT(61)),
NODE(CharRange, 2, VAL_FROM_INT(33), VAL_FROM_INT(33)),
NODE(CharRange, 2, VAL_FROM_INT(37), VAL_FROM_INT(37)),
NODE(CharRange, 2, VAL_FROM_INT(64), VAL_FROM_INT(64)))), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.func"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(CharGroupPredef, 1, TOKEN("char-group.predef", ".")),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.method"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(90)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.type"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(105),
VAL_FROM_INT(102),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.if"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(101),
VAL_FROM_INT(108),
VAL_FROM_INT(115),
VAL_FROM_INT(101),
VAL_FROM_INT(10))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.else"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(101),
VAL_FROM_INT(110),
VAL_FROM_INT(100),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.end"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(110),
VAL_FROM_INT(105),
VAL_FROM_INT(108),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("lit.nil"),
VAL_FROM_INT(0),
VAL_NIL)))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(116),
VAL_FROM_INT(114),
VAL_FROM_INT(117),
VAL_FROM_INT(101),
VAL_FROM_INT(10))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("lit.true"),
VAL_FROM_INT(0),
VAL_TRUE)))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(102),
VAL_FROM_INT(97),
VAL_FROM_INT(108),
VAL_FROM_INT(115),
VAL_FROM_INT(101),
VAL_FROM_INT(10))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("lit.const"),
VAL_FROM_INT(0),
VAL_FALSE)))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(118),
VAL_FROM_INT(97),
VAL_FROM_INT(114),
NODE(PredefAnchor, 1, TOKEN("anchor", "\\b")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("kw.var"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(45), TOKEN("quantifier", "?")),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\d")), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("lit.int"),
VAL_FROM_INT(0),
NODE(Call, 2, TOKEN("name.func", ":parse_int"), LIST(VAL_FROM_INT(0))))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(122)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("name.var"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(38),
VAL_FROM_INT(38))),
NODE(Seq, 1, LIST(VAL_FROM_INT(124),
VAL_FROM_INT(124))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.infix.logic"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(62))),
NODE(Seq, 1, LIST(VAL_FROM_INT(60))),
NODE(Seq, 1, LIST(VAL_FROM_INT(62),
VAL_FROM_INT(61))),
NODE(Seq, 1, LIST(VAL_FROM_INT(60),
VAL_FROM_INT(61))),
NODE(Seq, 1, LIST(VAL_FROM_INT(61),
VAL_FROM_INT(61))),
NODE(Seq, 1, LIST(VAL_FROM_INT(33),
VAL_FROM_INT(61))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.infix.compare"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(43))),
NODE(Seq, 1, LIST(VAL_FROM_INT(45))),
NODE(Seq, 1, LIST(VAL_FROM_INT(94))),
NODE(Seq, 1, LIST(VAL_FROM_INT(38))),
NODE(Seq, 1, LIST(VAL_FROM_INT(124))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.infix.additive"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(42),
VAL_FROM_INT(42))),
NODE(Seq, 1, LIST(VAL_FROM_INT(42))),
NODE(Seq, 1, LIST(VAL_FROM_INT(47))),
NODE(Seq, 1, LIST(VAL_FROM_INT(37))),
NODE(Seq, 1, LIST(VAL_FROM_INT(64))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.infix.multitive"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(91))))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\s")), TOKEN("quantifier", "*")),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(42))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.list"),
VAL_FROM_INT(1))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.prefix.splat"),
VAL_FROM_INT(2))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("[")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.list"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("]")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.list"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("(")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.paren"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c(")")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.paren"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("=")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.eq"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("!")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.prefix"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(44))))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\s")), TOKEN("quantifier", "*")),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(42))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("space.eol"),
VAL_FROM_INT(1))),
NODE(VarRef, 1, TOKEN("name.var", "token")),
STR("op.prefix.splat"),
VAL_FROM_INT(2))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(44), VAL_FROM_INT(44)),
NODE(CharRange, 2, VAL_FROM_INT(10), VAL_FROM_INT(10)))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("space.eol"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(35),
NODE(Quantified, 2, NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "[^"), LIST(NODE(CharRange, 2, VAL_FROM_INT(10), VAL_FROM_INT(10)))), TOKEN("quantifier", "*")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":style"), LIST(STR("comment"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")),
NODE(Group, 2, TOKEN("group.special", "?="), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(61))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("space.pre-eq"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST()))))))),
NODE(Lex, 2, TOKEN("kw.lex", "String"), LIST(NODE(BeginCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(34))))), LIST(NODE(Callback, 1, LIST(NODE(VarDecl, 1, TOKEN("name.var", "buf")),
NODE(Assign, 2, TOKEN("name.var", "buf"), STR("")),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.string"))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(34))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.string"))),
NODE(Call, 2, TOKEN("name.func", ":yield"), LIST(NODE(VarRef, 1, TOKEN("name.var", "buf")))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(92),
VAL_FROM_INT(120),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.hex"))),
NODE(Assign, 2, TOKEN("name.var", "buf"), NODE(Call, 2, TOKEN("name.func", ":concat_char"), LIST(NODE(VarRef, 1, TOKEN("name.var", "buf")),
NODE(Call, 2, TOKEN("name.func", ":char_hex"), LIST(VAL_FROM_INT(1)))))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(92),
VAL_FROM_INT(117),
VAL_FROM_INT(123),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")), TOKEN("quantifier", "+")))))),
VAL_FROM_INT(125))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.ux"))),
NODE(Assign, 2, TOKEN("name.var", "buf"), NODE(Call, 2, TOKEN("name.func", ":concat_char"), LIST(NODE(VarRef, 1, TOKEN("name.var", "buf")),
NODE(Call, 2, TOKEN("name.func", ":char_hex"), LIST(VAL_FROM_INT(1)))))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(92),
VAL_FROM_INT(117),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.u4"))),
NODE(Assign, 2, TOKEN("name.var", "buf"), NODE(Call, 2, TOKEN("name.func", ":concat_char"), LIST(NODE(VarRef, 1, TOKEN("name.var", "buf")),
NODE(Call, 2, TOKEN("name.func", ":char_hex"), LIST(VAL_FROM_INT(1)))))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(92),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(97)),
NODE(CharRange, 2, VAL_FROM_INT(98), VAL_FROM_INT(98)),
NODE(CharRange, 2, VAL_FROM_INT(102), VAL_FROM_INT(102)),
NODE(CharRange, 2, VAL_FROM_INT(116), VAL_FROM_INT(116)),
NODE(CharRange, 2, VAL_FROM_INT(110), VAL_FROM_INT(110)),
NODE(CharRange, 2, VAL_FROM_INT(114), VAL_FROM_INT(114)))))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.escape.sp"))),
NODE(Assign, 2, TOKEN("name.var", "buf"), NODE(Call, 2, TOKEN("name.func", ":concat_char"), LIST(NODE(VarRef, 1, TOKEN("name.var", "buf")),
NODE(Call, 2, TOKEN("name.func", ":char_escape_sp"), LIST(VAL_FROM_INT(1)))))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(92),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "[^"), LIST(NODE(CharRange, 2, VAL_FROM_INT(10), VAL_FROM_INT(10)))))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.escape"))),
NODE(Assign, 2, TOKEN("name.var", "buf"), NODE(Call, 2, TOKEN("name.func", ":concat_char"), LIST(NODE(VarRef, 1, TOKEN("name.var", "buf")),
NODE(Call, 2, TOKEN("name.func", ":char_no_escape"), LIST(VAL_FROM_INT(1)))))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(CharGroupPredef, 1, TOKEN("char-group.predef", ".")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char"))),
NODE(Assign, 2, TOKEN("name.var", "buf"), NODE(Call, 2, TOKEN("name.func", ":concat_char"), LIST(NODE(VarRef, 1, TOKEN("name.var", "buf")),
NODE(Call, 2, TOKEN("name.func", ":char_no_escape"), LIST(VAL_FROM_INT(0)))))))))))))),
NODE(Lex, 2, TOKEN("kw.lex", "Regexp"), LIST(NODE(BeginCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("/")), LIST(NODE(Callback, 1, LIST(NODE(VarDecl, 1, TOKEN("name.var", "cg_stack")),
NODE(Assign, 2, TOKEN("name.var", "cg_stack"), VAL_NIL),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.regexp"))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("/")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.regexp"))),
NODE(Call, 2, TOKEN("name.func", ":parse"), LIST()))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(94))),
NODE(Seq, 1, LIST(VAL_FROM_INT(36))),
NODE(Seq, 1, LIST(VAL_FROM_INT(92),
NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(98), VAL_FROM_INT(98)),
NODE(CharRange, 2, VAL_FROM_INT(66), VAL_FROM_INT(66)),
NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(97)),
NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(65)),
NODE(CharRange, 2, VAL_FROM_INT(122), VAL_FROM_INT(122)),
NODE(CharRange, 2, VAL_FROM_INT(90), VAL_FROM_INT(90)))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("anchor"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(92),
NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(100), VAL_FROM_INT(100)),
NODE(CharRange, 2, VAL_FROM_INT(68), VAL_FROM_INT(68)),
NODE(CharRange, 2, VAL_FROM_INT(119), VAL_FROM_INT(119)),
NODE(CharRange, 2, VAL_FROM_INT(87), VAL_FROM_INT(87)),
NODE(CharRange, 2, VAL_FROM_INT(104), VAL_FROM_INT(104)),
NODE(CharRange, 2, VAL_FROM_INT(72), VAL_FROM_INT(72)),
NODE(CharRange, 2, VAL_FROM_INT(115), VAL_FROM_INT(115)),
NODE(CharRange, 2, VAL_FROM_INT(83), VAL_FROM_INT(83)))))),
NODE(Seq, 1, LIST(VAL_FROM_INT(46))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char-group.predef"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(92),
VAL_FROM_INT(112),
VAL_FROM_INT(123),
NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(90)))),
NODE(Quantified, 2, NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(122)))), TOKEN("quantifier", "*")),
VAL_FROM_INT(125))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("unicode-char-class"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(RefContext, 1, TOKEN("name.context", "RegexpEscape")))),
NODE(RefPartialContext, 1, TOKEN("name.context.partial", "*RegexpQuantifier")),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("|")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.branch"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(91),
NODE(Quantified, 2, VAL_FROM_INT(94), TOKEN("quantifier", "?")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.char-group"))),
NODE(Assign, 2, TOKEN("name.var", "cg_stack"), NODE(CreateList, 1, LIST(NODE(SplatEntry, 1, NODE(VarRef, 1, TOKEN("name.var", "cg_stack"))),
VAL_TRUE))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("]")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.char-group"))),
NODE(Assign, 2, TOKEN("name.var", "cg_stack"), NODE(Call, 2, TOKEN("name.func", ":tail"), LIST(NODE(VarRef, 1, TOKEN("name.var", "cg_stack"))))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("-")), LIST(NODE(Callback, 1, LIST(NODE(VarRef, 1, TOKEN("name.var", "if")),
NODE(VarRef, 1, TOKEN("name.var", "cg_stack")),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("op.minus"))),
NODE(VarRef, 1, TOKEN("name.var", "else")),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(123),
NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(65), VAL_FROM_INT(90)))),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "*")),
VAL_FROM_INT(125))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("interpolate.predef"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("(?i)")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("flag.case-insensitive"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("(?I)")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("flag.case-sensitive"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(40),
VAL_FROM_INT(63),
VAL_FROM_INT(101),
VAL_FROM_INT(58),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")),
NODE(Quantified, 2, NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(45),
NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\w")), TOKEN("quantifier", "+")))))), TOKEN("quantifier", "?")),
VAL_FROM_INT(41))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("flag.encoding"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(40))))),
NODE(Quantified, 2, NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(58))),
NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(61))),
NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(33))),
NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(60),
VAL_FROM_INT(61))),
NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(60),
VAL_FROM_INT(33))),
NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(62))))), TOKEN("quantifier", "?")))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.group"),
VAL_FROM_INT(1))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("group.special"),
VAL_FROM_INT(2))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c(")")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.group"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\s")), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST()))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "[^"), LIST(NODE(CharRange, 2, VAL_FROM_INT(10), VAL_FROM_INT(10)),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\s")))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char"),
VAL_FROM_INT(0),
NODE(Call, 2, TOKEN("name.func", ":char_no_escape"), LIST(VAL_FROM_INT(0))))))))))))),
NODE(Lex, 2, TOKEN("kw.lex", "RegexpEscape"), LIST(NODE(BeginCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(String, 1, nb_string_new_literal_c("\\\\")), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.escape"))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(120),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.escape"))),
NODE(Call, 2, TOKEN("name.func", ":yield"), LIST(NODE(Call, 2, TOKEN("name.func", ":char_hex"), LIST(VAL_FROM_INT(1))))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(117),
VAL_FROM_INT(123),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")), TOKEN("quantifier", "+")))))),
VAL_FROM_INT(125))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.escape"))),
NODE(Call, 2, TOKEN("name.func", ":yield"), LIST(NODE(Call, 2, TOKEN("name.func", ":char_hex"), LIST(VAL_FROM_INT(1))))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(117),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")),
NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\h")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.escape"))),
NODE(Call, 2, TOKEN("name.func", ":yield"), LIST(NODE(Call, 2, TOKEN("name.func", ":char_hex"), LIST(VAL_FROM_INT(1))))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(97), VAL_FROM_INT(97)),
NODE(CharRange, 2, VAL_FROM_INT(98), VAL_FROM_INT(98)),
NODE(CharRange, 2, VAL_FROM_INT(102), VAL_FROM_INT(102)),
NODE(CharRange, 2, VAL_FROM_INT(116), VAL_FROM_INT(116)),
NODE(CharRange, 2, VAL_FROM_INT(110), VAL_FROM_INT(110)),
NODE(CharRange, 2, VAL_FROM_INT(114), VAL_FROM_INT(114)))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.escape"))),
NODE(Call, 2, TOKEN("name.func", ":yield"), LIST(NODE(Call, 2, TOKEN("name.func", ":char_escape_sp"), LIST(VAL_FROM_INT(0))))))))))),
NODE(EndCallback, 2, VAL_NIL, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "[^"), LIST(NODE(CharRange, 2, VAL_FROM_INT(10), VAL_FROM_INT(10)))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("char.escape"))),
NODE(Call, 2, TOKEN("name.func", ":yield"), LIST(NODE(Call, 2, TOKEN("name.func", ":char_no_escape"), LIST(VAL_FROM_INT(0))))))))))))),
NODE(Lex, 2, TOKEN("kw.lex", "*RegexpQuantifier"), LIST(NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(42),
VAL_FROM_INT(32))),
NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(63),
VAL_FROM_INT(32))),
NODE(Seq, 1, LIST(VAL_FROM_INT(63),
VAL_FROM_INT(32))),
NODE(Seq, 1, LIST(VAL_FROM_INT(43),
VAL_FROM_INT(42),
VAL_FROM_INT(32))),
NODE(Seq, 1, LIST(VAL_FROM_INT(43),
VAL_FROM_INT(63),
VAL_FROM_INT(32))),
NODE(Seq, 1, LIST(VAL_FROM_INT(43),
VAL_FROM_INT(32))),
NODE(Seq, 1, LIST(VAL_FROM_INT(42),
VAL_FROM_INT(42),
VAL_FROM_INT(32))),
NODE(Seq, 1, LIST(VAL_FROM_INT(42),
VAL_FROM_INT(63),
VAL_FROM_INT(32))),
NODE(Seq, 1, LIST(VAL_FROM_INT(42))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("quantifier"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(123))))),
VAL_FROM_INT(32),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\d")), TOKEN("quantifier", "+")))))),
VAL_FROM_INT(32),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(125))))),
VAL_FROM_INT(32),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(42), VAL_FROM_INT(42)),
NODE(CharRange, 2, VAL_FROM_INT(63), VAL_FROM_INT(63)))), TOKEN("quantifier", "?")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.quantifier"),
VAL_FROM_INT(1))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("quantifier.range.from"),
VAL_FROM_INT(2))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.quantifier"),
VAL_FROM_INT(3))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("quantifier.kind"),
VAL_FROM_INT(4))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(123))))),
VAL_FROM_INT(32),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\d")), TOKEN("quantifier", "+")))))),
VAL_FROM_INT(32),
VAL_FROM_INT(44),
VAL_FROM_INT(32),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, NODE(CharGroupPredef, 1, TOKEN("char-group.predef", "\\d")), TOKEN("quantifier", "*")))))),
VAL_FROM_INT(32),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(125))))),
VAL_FROM_INT(32),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "["), LIST(NODE(CharRange, 2, VAL_FROM_INT(42), VAL_FROM_INT(42)),
NODE(CharRange, 2, VAL_FROM_INT(63), VAL_FROM_INT(63)))), TOKEN("quantifier", "?")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("begin.quantifier"),
VAL_FROM_INT(1))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("quantifier.range.from"),
VAL_FROM_INT(2))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("quantifier.range.to"),
VAL_FROM_INT(3))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("end.quantifier"),
VAL_FROM_INT(4))),
NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("quantifier.kind"),
VAL_FROM_INT(5))))))))))),
NODE(Lex, 2, TOKEN("kw.lex", "*Spaces"), LIST(NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")),
NODE(Group, 2, TOKEN("group.special", "?="), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(123))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("space.pre-callback"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")),
NODE(Group, 2, TOKEN("group.special", "?="), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(61))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("space.pre-eq"))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "*")),
NODE(Quantified, 2, NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(35),
NODE(Quantified, 2, NODE(BracketCharGroup, 2, TOKEN("begin.char-group", "[^"), LIST(NODE(CharRange, 2, VAL_FROM_INT(10), VAL_FROM_INT(10)))), TOKEN("quantifier", "*")))))), TOKEN("quantifier", "?")),
NODE(Group, 2, TOKEN("group.special", ""), LIST(NODE(Seq, 1, LIST(VAL_FROM_INT(10))),
NODE(Seq, 1, LIST(NODE(PredefAnchor, 1, TOKEN("anchor", "\\z")))))))))), LIST(NODE(Callback, 1, LIST(NODE(Call, 2, TOKEN("name.func", ":token"), LIST(STR("space.eol"))),
NODE(Call, 2, TOKEN("name.func", ":style"), LIST(STR("comment"),
VAL_FROM_INT(1))))))))),
NODE(SeqLexRules, 1, LIST(NODE(LexRule, 2, NODE(Regexp, 1, LIST(NODE(Seq, 1, LIST(NODE(Quantified, 2, VAL_FROM_INT(32), TOKEN("quantifier", "+")))))), LIST(NODE(Callback, 1, LIST()))))))),
NODE(Peg, 2, TOKEN("kw.peg", "Main"), LIST(NODE(PegRule, 2, TOKEN("name.rule", "Main"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Line"), TOKEN("op.quantified", "*"))), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Main"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Line"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "space.eol"), VAL_NIL)), LIST()),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Ins"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Ins"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.pattern"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "name.pattern"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "space.pre-eq"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "op.eq"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Pattern"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "PatternIns"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(Capture, 1, TOKEN("name.var.capture", "$5")))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.var"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "name.var"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "VarDecl"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.lex"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "name.context"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Lex"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Lex"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.peg"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "name.context"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Peg"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Peg"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Pattern"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "String"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Regexp"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))),
NODE(Peg, 2, TOKEN("kw.peg", "Lex"), LIST(NODE(PegRule, 2, TOKEN("name.rule", "Lex"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "begin.lex"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "RuleLine"), TOKEN("op.quantified", "*")),
NODE(Term, 2, TOKEN("name.token", "end.lex"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")))))))),
NODE(PegRule, 2, TOKEN("name.rule", "RuleLine"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.context.partial"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "RefPartialContext"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.context"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "RefContext"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Rule"), TOKEN("op.quantified", "+"))), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "SeqLexRules"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.begin"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Callback"), TOKEN("op.quantified", "?")),
NODE(Term, 2, TOKEN("name.rule", "Rule"), TOKEN("op.quantified", "+"))), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "BeginCallback"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.end"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Callback"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Rule"), TOKEN("op.quantified", "+"))), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "EndCallback"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "space.eol"), VAL_NIL)), LIST())))),
NODE(PegRule, 2, TOKEN("name.rule", "Rule"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Pattern"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "space.pre-callback"), TOKEN("op.quantified", "*")),
NODE(Term, 2, TOKEN("name.rule", "Callback"), TOKEN("op.quantified", "?"))), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "LexRule"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3")))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Pattern"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "String"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Regexp"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.var"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "VarRef"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.var.global"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "GlobalVarRef"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))))),
NODE(Peg, 2, TOKEN("kw.peg", "Peg"), LIST(NODE(PegRule, 2, TOKEN("name.rule", "Peg"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "begin.peg"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Rule"), TOKEN("op.quantified", "*")),
NODE(Term, 2, TOKEN("name.token", "end.peg"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Rule"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.rule"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "op.def"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "space.eol"), TOKEN("op.quantified", "?")),
NODE(Term, 2, TOKEN("name.rule", "RuleBody"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "space.eol"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "PegRule"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$4")))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "space.eol"), VAL_NIL)), LIST())))),
NODE(PegRule, 2, TOKEN("name.rule", "RuleBody"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "SeqRule"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateList, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))),
NODE(BranchRight, 2, TOKEN("op.branch.quantified", ">*"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "space.eol"), TOKEN("op.quantified", "?")),
NODE(Term, 2, TOKEN("name.rule", "BranchRight"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateList, 1, LIST(NODE(SplatEntry, 1, NODE(Capture, 1, TOKEN("name.var.capture", "$1"))),
NODE(Capture, 1, TOKEN("name.var.capture", "$3"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "BranchRight"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.branch.quantified"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "SeqRule"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "BranchRight"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2")))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.branch"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "SeqRule"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "BranchRight"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.branch.op-table"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "OpBranchRight"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "SeqRule"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Term"), TOKEN("op.quantified", "+")),
NODE(Term, 2, TOKEN("name.rule", "Callback"), TOKEN("op.quantified", "?"))), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "SeqRule"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2")))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Term"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Name"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "op.quantified"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Term"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2")))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Name"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "op.extract"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Term"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Name"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "op.extract.maybe"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Term"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Name"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Term"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
VAL_NIL))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.lookahead"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "LookaheadName"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Lookahead"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Name"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.token"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.rule"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "LookaheadName"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.token"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.rule"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.pattern"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))),
NODE(Peg, 2, TOKEN("kw.peg", "Callback"), LIST(NODE(PegRule, 2, TOKEN("name.rule", "Callback"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "begin.code"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Stmt"), TOKEN("op.quantified", "*")),
NODE(Term, 2, TOKEN("name.token", "end.code"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Callback"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Stmt"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Expr"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "space.eol"), VAL_NIL)), LIST())),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.var"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "name.var"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "VarDecl"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Expr"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Infix.Logic"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Infix.Logic"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Infix.Compare"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch.quantified", ">*"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.infix.logic"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Infix.Compare"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "InfixLogic"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(CreateList, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$3")),
NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Infix.Compare"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Infix.Additive"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch.quantified", ">*"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.infix.compare"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Infix.Additive"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Call"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(CreateList, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$3")),
NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Infix.Additive"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Infix.Multitive"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch.quantified", ">*"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.infix.additive"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Infix.Multitive"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Call"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(CreateList, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$3")),
NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Infix.Multitive"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Unit"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch.quantified", ">*"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.infix.multitive"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Unit"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Call"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(CreateList, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$3")),
NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Unit"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "begin.paren"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Expr"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "end.paren"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.prefix"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Unit"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Call"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "lit.int"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "lit.true"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "lit.false"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "lit.nil"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "String"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.var.capture"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Capture"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.type"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "begin.list"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Entry"), TOKEN("op.quantified", "*")),
NODE(Term, 2, TOKEN("name.token", "end.list"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "CreateNode"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "begin.list"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Entry"), TOKEN("op.quantified", "*")),
NODE(Term, 2, TOKEN("name.token", "end.list"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "CreateList"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.func"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Expr"), TOKEN("op.quantified", "*"))), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Call"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.var"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "VarRef"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "If"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "name.var"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "space.pre-eq"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "op.eq"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Expr"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Assign"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$4"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Entry"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Expr"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.prefix.splat"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Expr"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "SplatEntry"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "space.eol"), VAL_NIL)), LIST())))),
NODE(PegRule, 2, TOKEN("name.rule", "Line"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Expr"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "space.eol"), VAL_NIL)), LIST())))),
NODE(PegRule, 2, TOKEN("name.rule", "If"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.if"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Expr"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "space.eol"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Line"), TOKEN("op.quantified", "*")),
NODE(Term, 2, TOKEN("name.rule", "If.Else"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "If"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(Capture, 1, TOKEN("name.var.capture", "$4")),
NODE(Capture, 1, TOKEN("name.var.capture", "$5")))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "If.Else"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.end"), VAL_NIL)), LIST()),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.else"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Line"), TOKEN("op.quantified", "*")),
NODE(Term, 2, TOKEN("name.token", "kw.end"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "kw.else"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "If"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))))),
NODE(Peg, 2, TOKEN("kw.peg", "Regexp"), LIST(NODE(PegRule, 2, TOKEN("name.rule", "Regexp"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "begin.regexp"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Branches"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "end.regexp"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Regexp"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Branches"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Seq"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateList, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))),
NODE(BranchRight, 2, TOKEN("op.branch.quantified", ">*"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "op.branch"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Seq"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateList, 1, LIST(NODE(SplatEntry, 1, NODE(Capture, 1, TOKEN("name.var.capture", "$1"))),
NODE(Capture, 1, TOKEN("name.var.capture", "$3"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Seq"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "SeqUnit"), TOKEN("op.quantified", "*"))), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Seq"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "SeqUnit"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "anchor"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "PredefAnchor"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "flag.case-insensitive"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Flag"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "flag.case-sensitive"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Flag"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "flag.encoding"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Flag"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Unit"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "quantifier"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Quantified"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Unit"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "begin.quantifier"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "quantifier.range.from"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "quantifier.range.to"), TOKEN("op.quantified", "?")),
NODE(Term, 2, TOKEN("name.token", "end.quantifier"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "quantifier.kind"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "QuantifiedRange"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3")),
NODE(Capture, 1, TOKEN("name.var.capture", "$4")),
NODE(Capture, 1, TOKEN("name.var.capture", "$6"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Unit"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Unit"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Unit"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "SingleChar"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "CharGroup"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "Group"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "interpolate.predef"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "SingleChar"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "RegexpEscape"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "char"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "Group"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "begin.group"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "group.special"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "Branches"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "end.group"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "Group"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$2")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3")))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "CharGroup"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "char-group.predef"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "CharGroupPredef"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "unicode-char-class"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "UnicodeCharClass"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.token", "begin.char-group"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "CharClass"), TOKEN("op.quantified", "+")),
NODE(Term, 2, TOKEN("name.token", "end.char-group"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "BracketCharGroup"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$2"))))))))))),
NODE(PegRule, 2, TOKEN("name.rule", "CharClass"), LIST(NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "CharGroup"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "SingleChar"), VAL_NIL),
NODE(Term, 2, TOKEN("name.token", "op.minus"), VAL_NIL),
NODE(Term, 2, TOKEN("name.rule", "SingleChar"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "CharRange"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$3"))))))))),
NODE(BranchRight, 2, TOKEN("op.branch", "/"), NODE(SeqRule, 2, LIST(NODE(Term, 2, TOKEN("name.rule", "SingleChar"), VAL_NIL)), LIST(NODE(Callback, 1, LIST(NODE(CreateNode, 2, TOKEN("name.type", "CharRange"), LIST(NODE(Capture, 1, TOKEN("name.var.capture", "$1")),
NODE(Capture, 1, TOKEN("name.var.capture", "$1")))))))))))))));
