# bootstrap: parse spellbreak lex/peg rules, and translate to action calls.

# we name the recursive call of compile functions the "AST"

# to save some work...:
#   - calbacks are dealt with mini-callback
#   - no need parse extract rule `!` and `?!`
#   - no need to preserve space.pre-callback and space.pre-eq
#   - no need to parse `>+`, `>?`
#   - no need to parse rules other than `lex` and `peg`
# but:
#   - still need to parse `>*`
#   - still need to duplicate AST calls of `peg Lex` and `peg Peg`

require_relative "mini-lex"
require_relative "mini-peg"

class MiniSb

  Main = Struct.new :ins
  class Main
    def eval
      multi_ins = MiniCallback.build_multi ins.map &:eval
      "NODE(Main, Main, 1, #{multi_ins})"
    end
  end

  def initialize src
    src = src.gsub(/(?<!\\)#[^\n]*/, '').gsub(/\ +$/, '')
    @lex = {}
    @peg = {}
    curr = nil
    src.lines.each do |line|
      if line =~ /^lex (\*?\w+) = \[/
        curr = (lex[$1] = '')
      elsif line =~ /^peg (\w+) = \[/
        curr = (peg[$1] = '')
      elsif line.strip == "]"
        curr = nil
      elsif curr
        curr << line
      elsif line.strip.empty?
        # blank line
      else
        raise "don't know what to do with line: #{line}"
      end
    end
  end
  attr_reader :lex, :peg

  def parse
    ins = []
    @lex.each do |ctx, src|
      ins << MiniLex.new(ctx, src).parse rescue (puts src; raise)
    end
    @peg.each do |ctx, src|
      ins << MiniPeg.new(ctx, src).parse rescue (puts src; raise)
    end
    Main.new ins
  end

  # check sliced string
  def debug_slice member
    send(member).each do |ctx, content|
      puts ctx
      puts content
      puts
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  require "pp"
  parser = MiniSb.new(File.read __dir__ + '/sb.sb')
  node = parser.parse
  # parser.debug_slice :peg
  # parser.debug_slice :lex

  ast = node.eval
  out_file = __dir__ + "/bootstrap.inc"
  File.open out_file, 'w' do |f|
    f.puts "// GENERATED BY mini-sb.rb WITH sb.sb"
    f.puts
    f.puts "return #{ast};"
  end

  # TODO validate check with actions and compile-main
  data = File.read out_file

  # report context,node
  puts "nodes:"
  puts "-" * 70
  data.scan(/NODE\((\w+), *(\w+)/).uniq.sort.each{|a,b| puts "#{a},#{b}"}

  # report actions
  actions = MiniCallback::Call.funcs.uniq.sort.map{|(f, arity)| "#{f.sub ':', ''}/#{arity}" }
  impl_actions = File.read(__dir__ + '/spellbreak.c').scan(/^static Val (\w+)_(\d+)\b/).map{|(f, arity)| "#{f}/#{arity}" }
  if !(actions - impl_actions).empty?
    puts
    puts "not in impl actions:"
    puts "-" * 70
    puts (actions - impl_actions)
  end
  if !(impl_actions - actions).empty?
    puts
    puts "redundant impl action:"
    puts "-" * 70
    puts (impl_actions - actions)
  end
end
