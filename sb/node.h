#pragma once

#include <adt/val.h>

// ST representation
// meta -> arena -> node

// NOTE before register, type should be compiled to use the full name like "Nabla:Main.X.1" to distinguish from:
// - different branches
// - rules in other contexts


// Inter-operating with Val data type:
// If the data is not VAL_IMM, then it is Val
// If the data is pointer and it is a wrapper node, then it wraps a Val
// Else it is other node kinds

// Life cycles:
// 1. new node meta -> node arena
// 2. build AST with node arena
// 3. traverse AST with switch..case... loop
//    3.1 new eval arena
//    3.2 alloc intermediate nodes with eval arena
//    3.3 delete eval arena
// 4. delete node arena -> node meta

// Data layouts:
// "@" - <wrapper_class, Val> - builtin wrapper
// "." - <eof_class, PdlexNodeLocation> - builtin universal EOF token
// "*" - <cons_class, left_cons, right> - list cons node
// ".some-token" - <some_token_class, PdlexNodeLocation> - lex token
// "<Lang:Ctx.SomeNode.1" - <some_node_class, Val[]> - syntax node

struct NodeClassStruct;
typedef struct NodeClassStruct NodeClass;

// for detecting type
typedef struct {
  NodeClass* klass;
} NodeHeader;

typedef struct {
  NodeClass* klass;
  Val attrs[];
} SyntaxNode;

typedef struct {
  NodeClass* klass;
  Val val;
} WrapperNode;

// get pointer to the location object
// NOTE `s - pos` is the start of the whole src
typedef struct { const char* s; int32_t pos, size, line, col; } PdlexNodeLocation;
typedef struct {
  NodeClass* klass;
  PdlexNodeLocation loc;
} TokenNode;

typedef struct {
  NodeClass* klass;
  Val e;
  Val list;
} ConsNode;

// register actions and nodes
struct PdlexNodeMetaStruct;
typedef struct PdlexNodeMetaStruct PdlexNodeMeta;

struct PdlexNodeArenaStruct;
typedef struct PdlexNodeArenaStruct PdlexNodeArena;

#pragma mark ## meta

// stores node meta info for one whole syntax
PdlexNodeMeta* nb_node_meta_new();
void nb_node_meta_delete(PdlexNodeMeta* meta);

// register meta for syntax node type
// returns the type Val generated by type name, multiple calls only register once, but validates whether meta info match
Val nb_node_meta_def_class(PdlexNodeMeta* meta, const char* context_name, const char* type_name, int32_t attr_size);

// register meta for token node type
// returns the type Val generated by type name, multiple calls only register once
Val nb_node_meta_def_token(PdlexNodeMeta* meta, const char* token_name);

// env can be: 0: both, 1: lex only, 2: peg only
void nb_node_meta_def_action(int env, const char* name, int32_t name_size, int32_t arity, void* func_ptr);

#pragma mark ## arena for allocation, it must know metadata for types too

PdlexNodeArena* nb_node_arena_new(PdlexNodeMeta* meta);

void nb_node_arena_push(PdlexNodeArena* arena);

void nb_node_arena_pop(PdlexNodeArena* arena);

void nb_node_arena_delete(PdlexNodeArena* arena);

#pragma mark ## node

Val nb_node_context_name(Val node);
Val nb_node_type_name(Val node);

// NOTE this function doesn't handle refcount change or malloc/free
Val nb_node_dup(PdlexNodeArena* arena, Val node);

void nb_node_debug(Val node);

bool nb_node_is_wrapper(Val node);

#pragma mark ## convert between node space and val space

Val nb_node_to_val(Val node);
Val nb_val_to_node(PdlexNodeArena* arena, Val val);

#pragma mark ## token node, locatable

// NOTE node_name without the '.' prefix
Val nb_token_node_new(PdlexNodeArena* arena, const char* node_name);

Val nb_token_node_new_c(PdlexNodeArena* arena, const char* node_name, const char* s);

Val nb_token_node_to_s(Val node);

Val nb_token_node_to_s_literal(Val node);

#pragma mark ## cons node, for holding S*, S+ results

Val nb_cons_node_new(PdlexNodeArena* arena, Val e, Val list);

Val nb_cons_node_reverse(PdlexNodeArena* arena, Val list);

#pragma mark ## syntax node

// NOTE node_name without "<" prefix
Val nb_syntax_node_new(PdlexNodeArena* arena, const char* context_name, const char* node_name);

// bootstrap helper
Val nb_syntax_node_new_v(PdlexNodeArena* arena, const char* context_name, const char* node_name, int32_t size, ...);

int32_t nb_syntax_node_size(Val node);

bool nb_syntax_node_is(Val node, const char* type);

#pragma mark ## wrapper node

Val nb_wrapper_node_new(PdlexNodeArena* arena, Val v);
